Index: src/main/java/chylex/hee/game/item/ItemTotemOfUndyingCustom.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chylex.hee.game.item\r\nimport chylex.hee.client.util.MC\r\nimport chylex.hee.game.entity.living.EntityMobVillagerDying\r\nimport chylex.hee.game.mechanics.trinket.TrinketHandler\r\nimport chylex.hee.init.ModItems\r\nimport chylex.hee.system.migration.forge.EventPriority\r\nimport chylex.hee.system.migration.forge.Side\r\nimport chylex.hee.system.migration.forge.Sided\r\nimport chylex.hee.system.migration.forge.SubscribeEvent\r\nimport chylex.hee.system.migration.vanilla.EntityLivingBase\r\nimport chylex.hee.system.migration.vanilla.EntityPlayer\r\nimport chylex.hee.system.migration.vanilla.EntityVillager\r\nimport chylex.hee.system.migration.vanilla.Potions\r\nimport chylex.hee.system.migration.vanilla.Sounds\r\nimport chylex.hee.system.util.facades.Resource\r\nimport chylex.hee.system.util.hasKey\r\nimport chylex.hee.system.util.heeTag\r\nimport chylex.hee.system.util.heeTagOrNull\r\nimport chylex.hee.system.util.makeEffect\r\nimport chylex.hee.system.util.playClient\r\nimport chylex.hee.system.util.posVec\r\nimport chylex.hee.system.util.selectExistingEntities\r\nimport chylex.hee.system.util.totalTime\r\nimport net.minecraft.entity.Entity\r\nimport net.minecraft.entity.player.PlayerEntity.REACH_DISTANCE\r\nimport net.minecraft.item.ItemStack\r\nimport net.minecraft.item.Items\r\nimport net.minecraft.particles.ParticleTypes\r\nimport net.minecraft.util.DamageSource\r\nimport net.minecraft.util.Hand\r\nimport net.minecraft.world.World\r\nimport net.minecraftforge.common.MinecraftForge\r\nimport net.minecraftforge.event.entity.living.LivingDeathEvent\r\n\r\nclass ItemTotemOfUndyingCustom(properties: Properties) : ItemAbstractTrinket(properties){\r\n\tprivate companion object{\r\n\t\tprivate const val SHAKING_TAG = \"Shaking\"\r\n\t}\r\n\t\r\n\tinit{\r\n\t\taddPropertyOverride(Resource.Custom(\"is_shaking\")){\r\n\t\t\tstack, _, _ -> if (stack.heeTagOrNull.hasKey(SHAKING_TAG)) 1F else 0F\r\n\t\t}\r\n\t\t\r\n\t\tMinecraftForge.EVENT_BUS.register(this)\r\n\t}\r\n\t\r\n\toverride fun getTranslationKey(): String{\r\n\t\treturn Items.TOTEM_OF_UNDYING.translationKey\r\n\t}\r\n\t\r\n\t// Trinket handling\r\n\t\r\n\toverride fun canPlaceIntoTrinketSlot(stack: ItemStack): Boolean{\r\n\t\treturn !stack.isDamaged\r\n\t}\r\n\t\r\n\t@Sided(Side.CLIENT)\r\n\toverride fun spawnClientTrinketBreakFX(target: Entity){\r\n\t\tMC.particleManager.emitParticleAtEntity(target, ParticleTypes.TOTEM_OF_UNDYING, 30)\r\n\t\tSounds.ITEM_TOTEM_USE.playClient(target.posVec, target.soundCategory)\r\n\t}\r\n\t\r\n\t// Death logic\r\n\t\r\n\t@SubscribeEvent(EventPriority.HIGHEST)\r\n\tfun onLivingDeath(e: LivingDeathEvent){\r\n\t\tif (e.source.canHarmInCreative()){\r\n\t\t\treturn\r\n\t\t}\r\n\t\t\r\n\t\tval player = e.entity as? EntityPlayer ?: return\r\n\t\tval trinketHandler = TrinketHandler.get(player)\r\n\t\t\r\n\t\tif (e.source == DamageSource.FALL && trinketHandler.isItemActive(ModItems.SCALE_OF_FREEFALL)){\r\n\t\t\treturn\r\n\t\t}\r\n\t\t\r\n\t\ttrinketHandler.transformIfActive(this){\r\n\t\t\tit.damage = it.maxDamage\r\n\t\t\t\r\n\t\t\tplayer.health = 1F\r\n\t\t\tplayer.clearActivePotions()\r\n\t\t\tplayer.addPotionEffect(Potions.REGENERATION.makeEffect(900, 1))\r\n\t\t\tplayer.addPotionEffect(Potions.ABSORPTION.makeEffect(100, 1))\r\n\t\t\te.isCanceled = true\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Villager logic\r\n\t\r\n\toverride fun inventoryTick(stack: ItemStack, world: World, entity: Entity, itemSlot: Int, isSelected: Boolean){\r\n\t\tif (world.isRemote || world.totalTime % 10L != 0L || canPlaceIntoTrinketSlot(stack) || entity !is EntityPlayer){\r\n\t\t\treturn\r\n\t\t}\r\n\t\t\r\n\t\tval isNearVillager = world.selectExistingEntities.inRange<EntityVillager>(entity.posVec, entity.getAttribute(REACH_DISTANCE).value).isNotEmpty()\r\n\t\tval wasNearVillager = stack.heeTagOrNull.hasKey(SHAKING_TAG)\r\n\t\t\r\n\t\tif (isNearVillager && !wasNearVillager){\r\n\t\t\tstack.heeTag.putBoolean(SHAKING_TAG, true)\r\n\t\t}\r\n\t\telse if (!isNearVillager && wasNearVillager){\r\n\t\t\tstack.heeTag.remove(SHAKING_TAG)\r\n\t\t}\r\n\t}\r\n\t\r\n\toverride fun itemInteractionForEntity(stack: ItemStack, player: EntityPlayer, target: EntityLivingBase, hand: Hand): Boolean{\r\n\t\tif (target !is EntityVillager || !player.isSneaking || canPlaceIntoTrinketSlot(stack)){\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t\r\n\t\tval world = target.world\r\n\t\t\r\n\t\tif (world.isRemote){\r\n\t\t\treturn true\r\n\t\t}\r\n\t\t\r\n\t\tstack.damage -= if (target.isChild) 1 else 2\r\n\t\tstack.heeTagOrNull?.remove(SHAKING_TAG)\r\n\t\t\r\n\t\tplayer.setHeldItem(hand, stack)\r\n\t\tplayer.cooldownTracker.setCooldown(this, 64)\r\n\t\t\r\n\t\tEntityMobVillagerDying(world).apply {\r\n\t\t\tcopyLocationAndAnglesFrom(target)\r\n\t\t\tcopyVillagerDataFrom(target)\r\n\t\t\tworld.addEntity(this)\r\n\t\t}\r\n\t\t\r\n\t\ttarget.remove()\r\n\t\treturn true\r\n\t}\r\n\t\r\n\t// Client side\r\n\t\r\n\toverride fun shouldCauseReequipAnimation(oldStack: ItemStack, newStack: ItemStack, slotChanged: Boolean): Boolean{\r\n\t\treturn slotChanged && super.shouldCauseReequipAnimation(oldStack, newStack, slotChanged)\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/chylex/hee/game/item/ItemTotemOfUndyingCustom.kt	(revision 41aa0b6695a1ac98e2d75beae7cb260618fe1f25)
+++ src/main/java/chylex/hee/game/item/ItemTotemOfUndyingCustom.kt	(date 1579529026807)
@@ -116,7 +116,7 @@
 			return true
 		}
 		
-		stack.damage -= if (target.isChild) 1 else 2
+		stack.damage -= if (target.isChild) 1 else 2 // TODO maybe reverse? hmmmmmmmm
 		stack.heeTagOrNull?.remove(SHAKING_TAG)
 		
 		player.setHeldItem(hand, stack)
Index: src/main/java/chylex/hee/game/entity/projectile/EntityProjectileSpatialDash.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chylex.hee.game.entity.projectile\r\nimport chylex.hee.HEE\r\nimport chylex.hee.client.sound.MovingSoundSpatialDash\r\nimport chylex.hee.client.util.MC\r\nimport chylex.hee.game.entity.util.SerializedEntity\r\nimport chylex.hee.game.fx.IFxData\r\nimport chylex.hee.game.fx.IFxHandler\r\nimport chylex.hee.game.particle.ParticleFadingSpot\r\nimport chylex.hee.game.particle.ParticleSmokeCustom\r\nimport chylex.hee.game.particle.spawner.ParticleSpawnerCustom\r\nimport chylex.hee.game.particle.util.IOffset.Gaussian\r\nimport chylex.hee.game.particle.util.IOffset.InBox\r\nimport chylex.hee.game.particle.util.IShape.Line\r\nimport chylex.hee.game.particle.util.IShape.Point\r\nimport chylex.hee.game.world.util.BlockEditor\r\nimport chylex.hee.game.world.util.Teleporter\r\nimport chylex.hee.init.ModEntities\r\nimport chylex.hee.init.ModSounds\r\nimport chylex.hee.network.client.PacketClientFX\r\nimport chylex.hee.system.migration.vanilla.EntityLivingBase\r\nimport chylex.hee.system.migration.vanilla.EntityPlayer\r\nimport chylex.hee.system.util.Pos\r\nimport chylex.hee.system.util.TagCompound\r\nimport chylex.hee.system.util.blocksMovement\r\nimport chylex.hee.system.util.ceilToInt\r\nimport chylex.hee.system.util.color.IRandomColor.Companion.IRandomColor\r\nimport chylex.hee.system.util.color.IntColor.Companion.RGB\r\nimport chylex.hee.system.util.component1\r\nimport chylex.hee.system.util.component2\r\nimport chylex.hee.system.util.component3\r\nimport chylex.hee.system.util.directionTowards\r\nimport chylex.hee.system.util.distanceSqTo\r\nimport chylex.hee.system.util.heeTag\r\nimport chylex.hee.system.util.nextInt\r\nimport chylex.hee.system.util.playClient\r\nimport chylex.hee.system.util.posVec\r\nimport chylex.hee.system.util.readCompactVec\r\nimport chylex.hee.system.util.scale\r\nimport chylex.hee.system.util.square\r\nimport chylex.hee.system.util.use\r\nimport chylex.hee.system.util.writeCompactVec\r\nimport net.minecraft.entity.Entity\r\nimport net.minecraft.entity.EntityType\r\nimport net.minecraft.entity.IProjectile\r\nimport net.minecraft.entity.MoverType.SELF\r\nimport net.minecraft.entity.projectile.ProjectileHelper\r\nimport net.minecraft.network.IPacket\r\nimport net.minecraft.network.PacketBuffer\r\nimport net.minecraft.util.SoundCategory\r\nimport net.minecraft.util.math.BlockPos\r\nimport net.minecraft.util.math.BlockRayTraceResult\r\nimport net.minecraft.util.math.EntityRayTraceResult\r\nimport net.minecraft.util.math.RayTraceContext\r\nimport net.minecraft.util.math.RayTraceContext.BlockMode\r\nimport net.minecraft.util.math.RayTraceContext.FluidMode\r\nimport net.minecraft.util.math.RayTraceResult\r\nimport net.minecraft.util.math.RayTraceResult.Type\r\nimport net.minecraft.util.math.Vec3d\r\nimport net.minecraft.world.World\r\nimport net.minecraftforge.event.ForgeEventFactory\r\nimport net.minecraftforge.fml.network.NetworkHooks\r\nimport java.util.Random\r\n\r\nclass EntityProjectileSpatialDash(type: EntityType<EntityProjectileSpatialDash>, world: World) : Entity(type, world), IProjectile{\r\n\tconstructor(world: World, owner: EntityLivingBase, speedMp: Float, distanceMp: Float) : this(ModEntities.SPATIAL_DASH, world){\r\n\t\tthis.owner = SerializedEntity(owner)\r\n\t\tthis.setPosition(owner.posX, owner.posY + owner.eyeHeight - 0.1, owner.posZ)\r\n\t\t\r\n\t\tval realSpeed = PROJECTILE_SPEED_BASE * speedMp\r\n\t\tval realDistance = PROJECTILE_DISTANCE_BASE * distanceMp\r\n\t\t\r\n\t\tval (dirX, dirY, dirZ) = Vec3d.fromPitchYaw(owner.rotationPitch, owner.rotationYaw)\r\n\t\tshoot(dirX, dirY, dirZ, realSpeed, 0F)\r\n\t\t\r\n\t\tthis.lifespan = (realDistance / realSpeed).ceilToInt().toShort()\r\n\t\tthis.range = realDistance\r\n\t}\r\n\t\r\n\tcompanion object{\r\n\t\tprivate const val PROJECTILE_SPEED_BASE = 1.5F\r\n\t\tprivate const val PROJECTILE_DISTANCE_BASE = 32 // max distance is 98 blocks\r\n\t\t\r\n\t\tprivate const val OWNER_TAG = \"Owner\"\r\n\t\tprivate const val LIFESPAN_TAG = \"Lifespan\"\r\n\t\tprivate const val RANGE_TAG = \"Range\"\r\n\t\t\r\n\t\tprivate val TELEPORT_OFFSETS: Array<BlockPos>\r\n\t\tprivate val TELEPORT = Teleporter(causedInstability = 15u)\r\n\t\t\r\n\t\tprivate val PARTICLE_TICK = ParticleSpawnerCustom(\r\n\t\t\ttype = ParticleFadingSpot,\r\n\t\t\tdata = ParticleFadingSpot.Data(color = IRandomColor { RGB(nextInt(30, 70), nextInt(70, 130), nextInt(100, 200)) }, lifespan = 20..25, scale = (0.1F)..(0.12F)),\r\n\t\t\tpos = InBox(0.2F),\r\n\t\t\tmot = Gaussian(0.008F),\r\n\t\t\tmaxRange = 64.0\r\n\t\t)\r\n\t\t\r\n\t\tprivate val PARTICLE_EXPIRE = ParticleSpawnerCustom(\r\n\t\t\ttype = ParticleSmokeCustom,\r\n\t\t\tdata = ParticleSmokeCustom.Data(color = RGB(240u), scale = 3F),\r\n\t\t\tpos = InBox(0.6F),\r\n\t\t\tmot = Gaussian(0.03F),\r\n\t\t\tmaxRange = 128.0\r\n\t\t)\r\n\t\t\r\n\t\tclass FxExpireData(private val point: Vec3d, private val ownerEntity: Entity?) : IFxData{\r\n\t\t\toverride fun write(buffer: PacketBuffer) = buffer.use {\r\n\t\t\t\twriteCompactVec(point)\r\n\t\t\t\twriteInt(ownerEntity?.entityId ?: -1)\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tval FX_EXPIRE = object : IFxHandler<FxExpireData>{\r\n\t\t\toverride fun handle(buffer: PacketBuffer, world: World, rand: Random) = buffer.use {\r\n\t\t\t\tval player = HEE.proxy.getClientSidePlayer() ?: return\r\n\t\t\t\tval playerPos = player.posVec\r\n\t\t\t\t\r\n\t\t\t\tval point = readCompactVec()\r\n\t\t\t\tval forceAudible = readInt() == player.entityId\r\n\t\t\t\t\r\n\t\t\t\tval soundPoint = if (forceAudible){\r\n\t\t\t\t\tval distance = playerPos.distanceTo(point)\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (distance < 10.0){\r\n\t\t\t\t\t\tpoint\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tplayerPos.add(playerPos.directionTowards(point).scale(10.0 + (distance - 10.0) * 0.04)) // makes the sound audible even at max distance of ~100 blocks\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tpoint\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tPARTICLE_EXPIRE.spawn(Point(point, 10), rand)\r\n\t\t\t\tModSounds.ENTITY_SPATIAL_DASH_EXPIRE.playClient(soundPoint, SoundCategory.PLAYERS)\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tinit{\r\n\t\t\tval offsets = mutableListOf<BlockPos>()\r\n\t\t\t\r\n\t\t\toffsets.add(Pos(0, 2, 0))\r\n\t\t\toffsets.add(Pos(0, 1, 0))\r\n\t\t\t\r\n\t\t\tfor(pos in BlockPos.getAllInBox(Pos(-1, -1, -1), Pos(1, 0, 1))){\r\n\t\t\t\toffsets.add(pos)\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\toffsets.add(Pos(0, -2, 0))\r\n\t\t\t\r\n\t\t\tTELEPORT_OFFSETS = offsets.toTypedArray()\r\n\t\t}\r\n\t\t\r\n\t\tprivate fun canTeleportPlayerOnTop(pos: BlockPos, world: World): Boolean{\r\n\t\t\treturn pos.blocksMovement(world) && !pos.up().blocksMovement(world) && !pos.up(2).blocksMovement(world)\r\n\t\t}\r\n\t\t\r\n\t\tprivate fun handleBlockHit(entity: EntityLivingBase, hit: Vec3d, motion: Vec3d, pos: BlockPos){\r\n\t\t\tif (canTeleportPlayerOnTop(pos, entity.world)){\r\n\t\t\t\tTELEPORT.toBlock(entity, pos.up())\r\n\t\t\t}\r\n\t\t\telse if (!(entity is EntityPlayer && BlockEditor.canBreak(pos, entity))){\r\n\t\t\t\thandleGenericHit(entity, hit, motion)\r\n\t\t\t}\r\n\t\t\telse if (!teleportEntityNear(entity, hit.add(motion.normalize().scale(1.74)), false)){\r\n\t\t\t\thandleGenericHit(entity, hit, motion)\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tprivate fun handleGenericHit(entity: EntityLivingBase, hit: Vec3d, motion: Vec3d){\r\n\t\t\tteleportEntityNear(entity, hit.add(motion.normalize().scale(-1.26)), true)\r\n\t\t}\r\n\t\t\r\n\t\tprivate fun teleportEntityNear(entity: EntityLivingBase, target: Vec3d, fallback: Boolean): Boolean{\r\n\t\t\tval world = entity.world\r\n\t\t\t\r\n\t\t\tval finalBlock = TELEPORT_OFFSETS\r\n\t\t\t\t.map { Pos(target.add(it.x.toDouble(), it.y.toDouble(), it.z.toDouble())) }\r\n\t\t\t\t.sortedBy { it.distanceSqTo(target) }\r\n\t\t\t\t.firstOrNull { canTeleportPlayerOnTop(it, world) }\r\n\t\t\t\r\n\t\t\tif (finalBlock != null){\r\n\t\t\t\tTELEPORT.toBlock(entity, finalBlock.up())\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\telse if (fallback){\r\n\t\t\t\tTELEPORT.toLocation(entity, target)\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate var owner: SerializedEntity\r\n\tprivate var lifespan: Short\r\n\tprivate var range: Float\r\n\t\r\n\tprivate val cappedMotionVec: Vec3d\r\n\t\tget(){\r\n\t\t\treturn if (motion.length() <= range)\r\n\t\t\t\tmotion\r\n\t\t\telse\r\n\t\t\t\tmotion.normalize().scale(range)\r\n\t\t}\r\n\t\r\n\tinit{\r\n\t\tnoClip = true\r\n\t}\r\n\t\r\n\toverride fun registerData(){}\r\n\t\r\n\toverride fun createSpawnPacket(): IPacket<*>{\r\n\t\treturn NetworkHooks.getEntitySpawningPacket(this)\r\n\t}\r\n\t\r\n\toverride fun shoot(dirX: Double, dirY: Double, dirZ: Double, velocity: Float, inaccuracy: Float){\r\n\t\tthis.motion = Vec3d(dirX, dirY, dirZ).normalize().scale(velocity)\r\n\t}\r\n\t\r\n\toverride fun tick(){\r\n\t\tif (world.isRemote){\r\n\t\t\tif (ticksExisted == 1){\r\n\t\t\t\tMC.instance.soundHandler.play(MovingSoundSpatialDash(this))\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tPARTICLE_TICK.spawn(Line(Vec3d(prevPosX, prevPosY, prevPosZ), posVec, 0.75), rand)\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tsuper.tick()\r\n\t\t\r\n\t\tif (!world.isRemote){\r\n\t\t\tval hitObject = determineHitObject()\r\n\t\t\t\r\n\t\t\tif (hitObject != null && hitObject.type != Type.MISS){\r\n\t\t\t\tval ownerEntity = owner.get(world)\r\n\t\t\t\t\r\n\t\t\t\tif (ownerEntity is EntityLivingBase && ownerEntity.world === world){\r\n\t\t\t\t\tif (hitObject is BlockRayTraceResult){\r\n\t\t\t\t\t\thandleBlockHit(ownerEntity, hitObject.hitVec, motion, hitObject.pos)\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\thandleGenericHit(ownerEntity, hitObject.hitVec, motion)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tremove()\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (--lifespan <= 0){\r\n\t\t\t\tsetExpired()\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\trange -= motion.length().toFloat()\r\n\t\t}\r\n\t\t\r\n\t\tmove(SELF, motion)\r\n\t}\r\n\t\r\n\tprivate fun determineHitObject(): RayTraceResult?{\r\n\t\tval currentPos = posVec\r\n\t\tval nextPos = currentPos.add(cappedMotionVec)\r\n\t\t\r\n\t\tval blockResult = world.rayTraceBlocks(RayTraceContext(currentPos, nextPos, BlockMode.COLLIDER, FluidMode.NONE, this)).takeIf { it.type == Type.BLOCK }\r\n\t\t\r\n\t\tval ownerEntity = owner.get(world)\r\n\t\tval tracedNextPos = blockResult?.hitVec ?: nextPos\r\n\t\t\r\n\t\tval entityResult = ProjectileHelper.rayTraceEntities(world, this, currentPos, nextPos, boundingBox.expand(motion).grow(1.0)){\r\n\t\t\t// the projectile itself cannot collide with anything, therefore not even itself\r\n\t\t\tit.canBeCollidedWith() && !it.isSpectator && it !== ownerEntity\r\n\t\t}?.let {\r\n\t\t\t// ProjectileHelper sets hitVec to the bottom of the entity, but that wouldn't work too nicely here\r\n\t\t\tit.entity.boundingBox.grow(0.3).rayTrace(currentPos, tracedNextPos).orElse(null)?.let { hit -> EntityRayTraceResult(it.entity, hit) }\r\n\t\t}\r\n\t\t\r\n\t\treturn (entityResult ?: blockResult)?.takeUnless { ForgeEventFactory.onProjectileImpact(this, it) }\r\n\t}\r\n\t\r\n\tprivate fun setExpired(){\r\n\t\tval ownerEntity = owner.get(world)\r\n\t\tval expirePos = posVec.add(cappedMotionVec)\r\n\t\t\r\n\t\tPacketClientFX(FX_EXPIRE, FxExpireData(expirePos, ownerEntity)).let {\r\n\t\t\tit.sendToAllAround(this, 32.0)\r\n\t\t\t\r\n\t\t\tif (ownerEntity is EntityPlayer && expirePos.squareDistanceTo(ownerEntity.posVec) > square(32)){\r\n\t\t\t\tit.sendToPlayer(ownerEntity)\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tremove()\r\n\t}\r\n\t\r\n\toverride fun writeAdditional(nbt: TagCompound) = nbt.heeTag.use {\r\n\t\towner.writeToNBT(this, OWNER_TAG)\r\n\t\tputShort(LIFESPAN_TAG, lifespan)\r\n\t\tputFloat(RANGE_TAG, range)\r\n\t}\r\n\t\r\n\toverride fun readAdditional(nbt: TagCompound) = nbt.heeTag.use {\r\n\t\towner.readFromNBT(this, OWNER_TAG)\r\n\t\tlifespan = getShort(LIFESPAN_TAG)\r\n\t\trange = getFloat(RANGE_TAG)\r\n\t}\r\n\t\r\n\tinit {\r\n\t\tthis.owner = SerializedEntity()\r\n\t\tthis.lifespan = 0\r\n\t\tthis.range = 0F\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/chylex/hee/game/entity/projectile/EntityProjectileSpatialDash.kt	(revision 41aa0b6695a1ac98e2d75beae7cb260618fe1f25)
+++ src/main/java/chylex/hee/game/entity/projectile/EntityProjectileSpatialDash.kt	(date 1579593033479)
@@ -180,6 +180,8 @@
 				.sortedBy { it.distanceSqTo(target) }
 				.firstOrNull { canTeleportPlayerOnTop(it, world) }
 			
+			// TODO kinda breaks when teleporting through a window from the inside of a village house
+			
 			if (finalBlock != null){
 				TELEPORT.toBlock(entity, finalBlock.up())
 				return true
Index: src/main/java/chylex/hee/game/block/BlockJarODust.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chylex.hee.game.block\r\nimport chylex.hee.game.block.entity.TileEntityJarODust\r\nimport chylex.hee.game.block.info.BlockBuilder\r\nimport chylex.hee.game.mechanics.dust.DustLayers\r\nimport chylex.hee.game.mechanics.dust.DustLayers.Side.BOTTOM\r\nimport chylex.hee.game.mechanics.dust.DustLayers.Side.TOP\r\nimport chylex.hee.game.mechanics.dust.DustType\r\nimport chylex.hee.system.migration.Facing.DOWN\r\nimport chylex.hee.system.migration.forge.Side\r\nimport chylex.hee.system.migration.forge.Sided\r\nimport chylex.hee.system.migration.vanilla.EntityLivingBase\r\nimport chylex.hee.system.migration.vanilla.EntityPlayer\r\nimport chylex.hee.system.migration.vanilla.TextComponentTranslation\r\nimport chylex.hee.system.util.NBTList.Companion.putList\r\nimport chylex.hee.system.util.getListOfCompounds\r\nimport chylex.hee.system.util.getTile\r\nimport chylex.hee.system.util.heeTag\r\nimport chylex.hee.system.util.heeTagOrNull\r\nimport chylex.hee.system.util.isTopSolid\r\nimport chylex.hee.system.util.size\r\nimport net.minecraft.block.BlockState\r\nimport net.minecraft.block.Blocks\r\nimport net.minecraft.client.util.ITooltipFlag\r\nimport net.minecraft.item.ItemStack\r\nimport net.minecraft.tileentity.TileEntity\r\nimport net.minecraft.util.BlockRenderLayer.TRANSLUCENT\r\nimport net.minecraft.util.Direction\r\nimport net.minecraft.util.Hand\r\nimport net.minecraft.util.math.AxisAlignedBB\r\nimport net.minecraft.util.math.BlockPos\r\nimport net.minecraft.util.math.BlockRayTraceResult\r\nimport net.minecraft.util.math.RayTraceResult\r\nimport net.minecraft.util.text.ITextComponent\r\nimport net.minecraft.world.IBlockReader\r\nimport net.minecraft.world.IWorld\r\nimport net.minecraft.world.IWorldReader\r\nimport net.minecraft.world.World\r\nimport net.minecraft.world.storage.loot.LootContext\r\nimport net.minecraft.world.storage.loot.LootParameters\r\n\r\nclass BlockJarODust(builder: BlockBuilder) : BlockSimpleShaped(builder, AABB){\r\n\tcompanion object{\r\n\t\tval AABB = AxisAlignedBB(0.1875, 0.0, 0.1875, 0.8125, 0.84375, 0.8125)\r\n\t\t\r\n\t\tconst val LAYERS_TAG = \"Layers\"\r\n\t}\r\n\t\r\n\toverride fun hasTileEntity(state: BlockState): Boolean{\r\n\t\treturn true\r\n\t}\r\n\t\r\n\toverride fun createTileEntity(state: BlockState, world: IBlockReader): TileEntity{\r\n\t\treturn TileEntityJarODust()\r\n\t}\r\n\t\r\n\t// ItemStack serialization\r\n\t\r\n\tfun getLayersFromStack(stack: ItemStack): DustLayers?{\r\n\t\treturn if (stack.item === this.asItem())\r\n\t\t\tstack.heeTagOrNull?.getListOfCompounds(LAYERS_TAG)?.let { list -> DustLayers(TileEntityJarODust.DUST_CAPACITY).apply { deserializeNBT(list) } }\r\n\t\telse\r\n\t\t\tnull\r\n\t}\r\n\t\r\n\tfun setLayersInStack(stack: ItemStack, layers: DustLayers){\r\n\t\tif (stack.item === this.asItem()){\r\n\t\t\tstack.heeTag.putList(LAYERS_TAG, layers.serializeNBT())\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Placement\r\n\t\r\n\toverride fun isValidPosition(state: BlockState, world: IWorldReader, pos: BlockPos): Boolean{\r\n\t\treturn super.isValidPosition(state, world, pos) && pos.down().isTopSolid(world)\r\n\t}\r\n\t\r\n\toverride fun updatePostPlacement(state: BlockState, facing: Direction, neighborState: BlockState, world: IWorld, pos: BlockPos, neighborPos: BlockPos): BlockState{\r\n\t\treturn if (facing == DOWN && !isValidPosition(state, world, pos))\r\n\t\t\tBlocks.AIR.defaultState\r\n\t\telse\r\n\t\t\tsuper.updatePostPlacement(state, facing, neighborState, world, pos, neighborPos)\r\n\t}\r\n\t\r\n\toverride fun onBlockPlacedBy(world: World, pos: BlockPos, state: BlockState, placer: EntityLivingBase?, stack: ItemStack){\r\n\t\tval list = stack.heeTagOrNull?.getListOfCompounds(LAYERS_TAG)\r\n\t\t\r\n\t\tif (list != null){\r\n\t\t\tpos.getTile<TileEntityJarODust>(world)?.layers?.deserializeNBT(list)\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Drops\r\n\t\r\n\tprivate fun getDrop(tile: TileEntityJarODust): ItemStack?{\r\n\t\treturn ItemStack(this).also { setLayersInStack(it, tile.layers) }\r\n\t}\r\n\t\r\n\toverride fun getDrops(state: BlockState, context: LootContext.Builder): MutableList<ItemStack>{\r\n\t\tval drop = (context.get(LootParameters.BLOCK_ENTITY) as? TileEntityJarODust)?.let(::getDrop)\r\n\t\t\r\n\t\treturn if (drop != null)\r\n\t\t\tmutableListOf(drop)\r\n\t\telse\r\n\t\t\tmutableListOf()\r\n\t}\r\n\t\r\n\toverride fun getPickBlock(state: BlockState, target: RayTraceResult, world: IBlockReader, pos: BlockPos, player: EntityPlayer): ItemStack{\r\n\t\treturn pos.getTile<TileEntityJarODust>(world)?.let(::getDrop) ?: ItemStack(this)\r\n\t}\r\n\t\r\n\t\r\n\t// Interaction\r\n\t\r\n\toverride fun onBlockActivated(state: BlockState, world: World, pos: BlockPos, player: EntityPlayer, hand: Hand, hit: BlockRayTraceResult): Boolean{\r\n\t\tval heldItem = player.getHeldItem(hand)\r\n\t\t\r\n\t\treturn if (heldItem.isEmpty)\r\n\t\t\ttryExtractDust(world, pos, player, hand)\r\n\t\telse\r\n\t\t\ttryInsertDust(world, pos, player, heldItem)\r\n\t}\r\n\t\r\n\tprivate fun tryExtractDust(world: World, pos: BlockPos, player: EntityPlayer, hand: Hand): Boolean{\r\n\t\tif (world.isRemote){\r\n\t\t\treturn true\r\n\t\t}\r\n\t\t\r\n\t\tval removed = pos.getTile<TileEntityJarODust>(world)?.layers?.removeDust(if (player.isSneaking) BOTTOM else TOP)\r\n\t\t\r\n\t\tif (removed != null){\r\n\t\t\tplayer.setHeldItem(hand, removed)\r\n\t\t}\r\n\t\t\r\n\t\treturn true\r\n\t}\r\n\t\r\n\tprivate fun tryInsertDust(world: World, pos: BlockPos, player: EntityPlayer, stack: ItemStack): Boolean{\r\n\t\tval dustType = DustType.fromStack(stack) ?: return false\r\n\t\t\r\n\t\tif (world.isRemote){\r\n\t\t\treturn true\r\n\t\t}\r\n\t\t\r\n\t\tval tile = pos.getTile<TileEntityJarODust>(world) ?: return true\r\n\t\tval added = tile.layers.addDust(dustType, stack.size)\r\n\t\t\r\n\t\tif (!player.isCreative){\r\n\t\t\tstack.size -= added\r\n\t\t}\r\n\t\t\r\n\t\treturn true\r\n\t}\r\n\t\r\n\t// Client side\r\n\t\r\n\t@Sided(Side.CLIENT)\r\n\toverride fun addInformation(stack: ItemStack, world: IBlockReader?, lines: MutableList<ITextComponent>, flags: ITooltipFlag){\r\n\t\tval contents = getLayersFromStack(stack)?.contents\r\n\t\t\r\n\t\tif (contents != null){\r\n\t\t\tval entries = contents\r\n\t\t\t\t.groupingBy { it.first }\r\n\t\t\t\t.fold(0){ acc, entry -> acc + entry.second }\r\n\t\t\t\t.entries\r\n\t\t\t\t.sortedWith(compareBy({ -it.value }, { it.key.key }))\r\n\t\t\t\r\n\t\t\tfor((dustType, dustAmount) in entries){\r\n\t\t\t\tlines.add(TextComponentTranslation(\"block.hee.jar_o_dust.tooltip.entry\", dustAmount, TextComponentTranslation(dustType.item.translationKey)))\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\toverride fun getRenderLayer() = TRANSLUCENT\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/chylex/hee/game/block/BlockJarODust.kt	(revision 41aa0b6695a1ac98e2d75beae7cb260618fe1f25)
+++ src/main/java/chylex/hee/game/block/BlockJarODust.kt	(date 1579529026804)
@@ -108,6 +108,7 @@
 		return pos.getTile<TileEntityJarODust>(world)?.let(::getDrop) ?: ItemStack(this)
 	}
 	
+	// TODO maybe drop dusts after an explosion
 	
 	// Interaction
 	
